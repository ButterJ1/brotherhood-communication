<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brotherhood Âä†ÂØÜÈÄöË®ä - Á¨¨‰∫åÈöéÊÆµ</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #5671e8 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 1100px;
            height: 800px;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .main-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 20px 20px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .encryption-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .encryption-icon {
            width: 16px;
            height: 16px;
            background: #ffc107;
            border-radius: 50%;
        }

        .encryption-icon.encrypted {
            background: #28a745;
        }

        .connection-section {
            margin-bottom: 20px;
        }

        .connection-section h3 {
            margin-bottom: 10px;
            color: #495057;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .input-group {
            margin-bottom: 10px;
        }

        .input-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 14px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
            width: 100%;
            margin-bottom: 5px;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #1e7e34;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .status {
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 12px;
            text-align: center;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.encrypted {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .online-users {
            flex: 1;
            overflow-y: auto;
            max-height: 150px;
        }

        .user-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #e9ecef;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-item:hover {
            background: #dee2e6;
        }

        .user-item.selected {
            background: #007bff;
            color: white;
        }

        .user-encryption {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ffc107;
        }

        .user-encryption.encrypted {
            background: #28a745;
        }

        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            max-width: 70%;
        }

        .message.sent {
            margin-left: auto;
        }

        .message.received {
            margin-right: auto;
        }

        .message-content {
            padding: 10px 15px;
            border-radius: 20px;
            word-wrap: break-word;
        }

        .message.sent .message-content {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
        }

        .message.received .message-content {
            background: white;
            border: 1px solid #e9ecef;
        }

        .message-info {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
            padding: 0 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .encryption-badge {
            font-size: 10px;
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
        }

        .message-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
        }

        .message-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 25px;
            outline: none;
        }

        .message-input button {
            padding: 10px 20px;
            border-radius: 25px;
        }

        .logs {
            height: 120px;
            overflow-y: auto;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            margin-top: 10px;
        }

        .log-entry {
            margin-bottom: 3px;
            color: #495057;
        }

        .log-entry.error {
            color: #dc3545;
        }

        .log-entry.success {
            color: #28a745;
        }

        .log-entry.crypto {
            color: #007bff;
        }

        .crypto-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .key-info {
            background: #e7f3ff;
            border: 1px solid #b8daff;
            border-radius: 5px;
            padding: 8px;
            font-size: 11px;
            margin-bottom: 10px;
        }

        .key-id {
            font-family: monospace;
            color: #495057;
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ÂÅ¥ÈÇäÊ¨Ñ -->
        <div class="sidebar">
            <!-- ÈÄ£Á∑öÂçÄÂüü -->
            <div class="connection-section">
                <h3>üîó ÈÄ£Á∑öË®≠ÂÆö</h3>
                <div class="input-group">
                    <input type="text" id="username" placeholder="Áî®Êà∂ÂêçÁ®±" value="Âä†ÂØÜÁî®Êà∂1">
                </div>
                <div class="input-group">
                    <input type="text" id="userId" placeholder="Áî®Êà∂ID" value="enc_user1">
                </div>
                <button class="btn btn-primary" id="connectBtn" onclick="connect()">ÈÄ£Á∑ö</button>
                <button class="btn btn-danger" id="disconnectBtn" onclick="disconnect()" style="display:none;">Êñ∑Á∑ö</button>
                
                <div id="connectionStatus" class="status disconnected">Êú™ÈÄ£Á∑ö</div>
            </div>

            <!-- Âä†ÂØÜÊéßÂà∂ -->
            <div class="connection-section">
                <h3>üîê Âä†ÂØÜÊéßÂà∂</h3>
                <div class="crypto-controls">
                    <button class="btn btn-warning" onclick="initializeCrypto()" id="initCryptoBtn" disabled>ÂàùÂßãÂåñÂä†ÂØÜ</button>
                </div>
                <div id="encryptionStatus" class="status disconnected">Âä†ÂØÜÊú™Â∞±Á∑í</div>
                
                <div id="keyInfo" class="key-info" style="display:none;">
                    <div>Áï∂ÂâçÂØÜÈë∞ID:</div>
                    <div class="key-id" id="currentKeyId">-</div>
                </div>
            </div>

            <!-- Á∑ö‰∏äÁî®Êà∂ -->
            <div class="connection-section">
                <h3>üë• Á∑ö‰∏äÁî®Êà∂</h3>
                <div class="online-users" id="onlineUsers">
                    <div style="color: #6c757d; font-size: 12px; text-align: center;">Â∞öÁÑ°Á∑ö‰∏äÁî®Êà∂</div>
                </div>
            </div>

            <!-- Êó•Ë™å -->
            <div class="connection-section">
                <h3>üìù Á≥ªÁµ±Êó•Ë™å</h3>
                <div class="logs" id="logs"></div>
            </div>
        </div>

        <!-- ‰∏ªËÅäÂ§©ÂçÄÂüü -->
        <div class="main-chat">
            <div class="chat-header">
                <span id="chatTitle">Brotherhood Âä†ÂØÜÈÄöË®ä (Á¨¨‰∫åÈöéÊÆµ)</span>
                <div class="encryption-status">
                    <div class="encryption-icon" id="encryptionIcon"></div>
                    <span id="encryptionText">Êú™Âä†ÂØÜ</span>
                </div>
            </div>
            
            <div class="messages" id="messages">
                <div style="text-align: center; color: #6c757d; margin-top: 50px;">
                    <h3>üîê Ê≠°Ëøé‰ΩøÁî® Brotherhood Âä†ÂØÜÈÄöË®äÁ≥ªÁµ±</h3>
                    <p>Á¨¨‰∫åÈöéÊÆµÔºöÁ´ØÂà∞Á´ØÂä†ÂØÜÂäüËÉΩ</p>
                    <br>
                    <p>1. ÂÖàÈÄ£Á∑öÂà∞ÊúçÂãôÂô®</p>
                    <p>2. ÂàùÂßãÂåñÂä†ÂØÜÁ≥ªÁµ±</p>
                    <p>3. ÈÅ∏ÊìáÁ∑ö‰∏äÁî®Êà∂ÈñãÂßãÂä†ÂØÜËÅäÂ§©</p>
                </div>
            </div>
            
            <div class="message-input">
                <input type="text" id="messageInput" placeholder="Ëº∏ÂÖ•Ë®äÊÅØÔºàÂ∞áËá™ÂãïÂä†ÂØÜÔºâ..." disabled onkeypress="handleEnterKey(event)">
                <button class="btn btn-success" id="sendBtn" onclick="sendEncryptedMessage()" disabled>üîê ÁôºÈÄÅ</button>
            </div>
        </div>
    </div>

    <script>
        let socket = null;
        let currentUser = null;
        let selectedRecipient = null;
        let cryptoManager = null;
        let isEncryptionReady = false;

        // Âä†ÂØÜÁÆ°ÁêÜÂô®
        class CryptoManager {
            constructor() {
                this.myKeyPair = null; // ÊàëÁöÑ ECDH ÂØÜÈë∞Â∞ç
                this.sharedSecrets = new Map(); // ËàáÂÖ∂‰ªñÁî®Êà∂ÁöÑÂÖ±‰∫´ÂØÜÈë∞
                this.publicKeys = new Map(); // ÂÖ∂‰ªñÁî®Êà∂ÁöÑÂÖ¨Èë∞
                this.kaclsUrl = this.detectKaclsUrl();
            }

            // Ëá™ÂãïÊ™¢Ê∏¨ KACLS URL
            detectKaclsUrl() {
                const currentPort = window.location.port;
                return currentPort === '3001' ? 'http://localhost:3002' : '/api/kacls';
            }

            // ÂàùÂßãÂåñÂä†ÂØÜÁ≥ªÁµ± - ÁîüÊàêÂØÜÈë∞Â∞ç
            async initialize(userId) {
                try {
                    addLog('Ê≠£Âú®ÂàùÂßãÂåñÂä†ÂØÜÁ≥ªÁµ±...', 'crypto');
                    
                    // ÁîüÊàê ECDH ÂØÜÈë∞Â∞ç
                    this.myKeyPair = await crypto.subtle.generateKey(
                        {
                            name: "ECDH",
                            namedCurve: "P-256"
                        },
                        false, // ‰∏çÂèØÊèêÂèñÁßÅÈë∞
                        ["deriveKey"]
                    );

                    // Â∞éÂá∫ÂÖ¨Èë∞
                    const publicKeyBuffer = await crypto.subtle.exportKey(
                        "raw",
                        this.myKeyPair.publicKey
                    );
                    
                    const publicKeyHex = this.arrayBufferToHex(publicKeyBuffer);
                    
                    // Âêë KACLS Ë®ªÂÜäÂÖ¨Èë∞
                    await this.registerPublicKey(userId, publicKeyHex);
                    
                    addLog(`üîê ÂØÜÈë∞Â∞çÁîüÊàêÂÆåÊàêÔºåÂÖ¨Èë∞Â∑≤Ë®ªÂÜä`, 'success');
                    return true;
                    
                } catch (error) {
                    addLog(`Âä†ÂØÜÂàùÂßãÂåñÂ§±Êïó: ${error.message}`, 'error');
                    throw error;
                }
            }

            // Âêë KACLS Ë®ªÂÜäÂÖ¨Èë∞
            async registerPublicKey(userId, publicKeyHex) {
                try {
                    const response = await fetch(`${this.kaclsUrl}/api/register-public-key`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            userId: userId,
                            publicKey: publicKeyHex,
                            algorithm: 'ECDH-P256'
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`ÂÖ¨Èë∞Ë®ªÂÜäÂ§±Êïó: ${response.status}`);
                    }

                    const result = await response.json();
                    addLog(`ÂÖ¨Èë∞Ë®ªÂÜäÊàêÂäü: ${result.keyId}`, 'crypto');
                    
                } catch (error) {
                    addLog(`ÂÖ¨Èë∞Ë®ªÂÜäÂ§±Êïó: ${error.message}`, 'error');
                    throw error;
                }
            }

            // Áç≤ÂèñÂÖ∂‰ªñÁî®Êà∂ÁöÑÂÖ¨Èë∞
            async getPublicKey(userId) {
                try {
                    if (this.publicKeys.has(userId)) {
                        return this.publicKeys.get(userId);
                    }

                    const response = await fetch(`${this.kaclsUrl}/api/get-public-key/${userId}`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`Áç≤ÂèñÂÖ¨Èë∞Â§±Êïó: ${response.status}`);
                    }

                    const result = await response.json();
                    
                    // Â∞éÂÖ•ÂÖ¨Èë∞
                    const publicKeyBuffer = this.hexToArrayBuffer(result.publicKey);
                    const publicKey = await crypto.subtle.importKey(
                        "raw",
                        publicKeyBuffer,
                        {
                            name: "ECDH",
                            namedCurve: "P-256"
                        },
                        false,
                        []
                    );

                    this.publicKeys.set(userId, publicKey);
                    addLog(`Áç≤ÂèñÁî®Êà∂ ${userId} ÂÖ¨Èë∞ÊàêÂäü`, 'crypto');
                    return publicKey;
                    
                } catch (error) {
                    addLog(`Áç≤ÂèñÂÖ¨Èë∞Â§±Êïó: ${error.message}`, 'error');
                    throw error;
                }
            }

            // ÁîüÊàêËàáÁâπÂÆöÁî®Êà∂ÁöÑÂÖ±‰∫´ÂØÜÈë∞
            async getSharedSecret(otherUserId) {
                try {
                    if (this.sharedSecrets.has(otherUserId)) {
                        return this.sharedSecrets.get(otherUserId);
                    }

                    // Áç≤ÂèñÂ∞çÊñπÂÖ¨Èë∞
                    const otherPublicKey = await this.getPublicKey(otherUserId);

                    // Âü∑Ë°å ECDH ÂØÜÈë∞‰∫§Êèõ
                    const sharedKey = await crypto.subtle.deriveKey(
                        {
                            name: "ECDH",
                            public: otherPublicKey
                        },
                        this.myKeyPair.privateKey,
                        {
                            name: "AES-GCM",
                            length: 256
                        },
                        false,
                        ["encrypt", "decrypt"]
                    );

                    this.sharedSecrets.set(otherUserId, sharedKey);
                    addLog(`Ëàá ${otherUserId} ÁöÑÂÖ±‰∫´ÂØÜÈë∞ÁîüÊàêÂÆåÊàê`, 'crypto');
                    return sharedKey;
                    
                } catch (error) {
                    addLog(`ÂÖ±‰∫´ÂØÜÈë∞ÁîüÊàêÂ§±Êïó: ${error.message}`, 'error');
                    throw error;
                }
            }

            // Âä†ÂØÜË®äÊÅØ
            async encryptMessage(plaintext, recipientId) {
                try {
                    // Áç≤ÂèñËàáÊî∂‰ª∂‰∫∫ÁöÑÂÖ±‰∫´ÂØÜÈë∞
                    const sharedKey = await this.getSharedSecret(recipientId);
                    
                    // Ê∫ñÂÇôÊï∏Êìö
                    const encoder = new TextEncoder();
                    const data = encoder.encode(plaintext);
                    
                    // ÁîüÊàêÈö®Ê©ü IV
                    const iv = crypto.getRandomValues(new Uint8Array(12)); // GCM Âª∫Ë≠∞ 12 bytes
                    
                    // Âä†ÂØÜÊï∏Êìö
                    const encryptedData = await crypto.subtle.encrypt(
                        {
                            name: "AES-GCM",
                            iv: iv
                        },
                        sharedKey,
                        data
                    );
                    
                    const result = {
                        encryptedData: this.arrayBufferToHex(encryptedData),
                        iv: this.arrayBufferToHex(iv),
                        algorithm: 'ECDH-AES-GCM',
                        timestamp: Date.now()
                    };
                    
                    addLog(`Ë®äÊÅØÂä†ÂØÜÂÆåÊàê (ECDH)`, 'crypto');
                    return result;
                    
                } catch (error) {
                    addLog(`Ë®äÊÅØÂä†ÂØÜÂ§±Êïó: ${error.message}`, 'error');
                    throw error;
                }
            }

            // Ëß£ÂØÜË®äÊÅØ
            async decryptMessage(encryptedMessage, senderId) {
                try {
                    const { encryptedData, iv, algorithm } = encryptedMessage;
                    
                    if (algorithm !== 'ECDH-AES-GCM') {
                        throw new Error(`‰∏çÊîØÊåÅÁöÑÂä†ÂØÜÁÆóÊ≥ï: ${algorithm}`);
                    }
                    
                    // Áç≤ÂèñËàáÁôºÈÄÅËÄÖÁöÑÂÖ±‰∫´ÂØÜÈë∞
                    const sharedKey = await this.getSharedSecret(senderId);
                    
                    // Ëß£ÂØÜÊï∏Êìö
                    const decryptedData = await crypto.subtle.decrypt(
                        {
                            name: "AES-GCM",
                            iv: this.hexToArrayBuffer(iv)
                        },
                        sharedKey,
                        this.hexToArrayBuffer(encryptedData)
                    );
                    
                    const decoder = new TextDecoder();
                    const plaintext = decoder.decode(decryptedData);
                    
                    addLog(`Ë®äÊÅØËß£ÂØÜÂÆåÊàê (ECDH)`, 'crypto');
                    return plaintext;
                    
                } catch (error) {
                    addLog(`Ë®äÊÅØËß£ÂØÜÂ§±Êïó: ${error.message}`, 'error');
                    throw error;
                }
            }

            // Â∑•ÂÖ∑ÂáΩÊï∏
            hexToArrayBuffer(hex) {
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
                }
                return bytes.buffer;
            }

            arrayBufferToHex(buffer) {
                const bytes = new Uint8Array(buffer);
                return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
            }
        }

        // ÈÄ£Á∑öÂà∞ÊúçÂãôÂô®
        function connect() {
            const username = document.getElementById('username').value.trim();
            const userId = document.getElementById('userId').value.trim();

            if (!username || !userId) {
                addLog('Ë´ãËº∏ÂÖ•Áî®Êà∂ÂêçÁ®±ÂíåID', 'error');
                return;
            }

            // ÂâµÂª∫ Socket ÈÄ£Á∑ö
            socket = io('http://localhost:3001');

            // ÈÄ£Á∑ö‰∫ã‰ª∂
            socket.on('connect', () => {
                addLog('ÈÄ£Á∑öÊàêÂäüÔºåÊ≠£Âú®Ë®ªÂÜä...', 'success');
                
                // Ë®ªÂÜäÁî®Êà∂
                socket.emit('register', { username, userId });
            });

            // Ë®ªÂÜäÊàêÂäü
            socket.on('registerSuccess', (data) => {
                currentUser = data.user;
                updateConnectionStatus(true);
                addLog(`Ë®ªÂÜäÊàêÂäüÔºö${username}`, 'success');
                
                // ÂïüÁî®Ë®äÊÅØËº∏ÂÖ•ÂíåÂä†ÂØÜÂàùÂßãÂåñ
                document.getElementById('initCryptoBtn').disabled = false;
            });

            // Êñ∞Ë®äÊÅØ
            socket.on('newMessage', async (message) => {
                await handleIncomingMessage(message);
            });

            // Âä†ÂØÜË®äÊÅØ
            socket.on('encryptedMessage', async (encryptedMessage) => {
                await handleIncomingEncryptedMessage(encryptedMessage);
            });

            // Áî®Êà∂‰∏äÁ∑ö
            socket.on('userOnline', (data) => {
                addLog(`${data.user.username} ‰∏äÁ∑ö‰∫Ü`);
                updateOnlineUsers();
            });

            // Áî®Êà∂Èõ¢Á∑ö
            socket.on('userOffline', (data) => {
                addLog(`${data.username} Èõ¢Á∑ö‰∫Ü`);
                updateOnlineUsers();
            });

            // Ë®äÊÅØÈÄÅÈÅîÁ¢∫Ë™ç
            socket.on('messageDelivered', (data) => {
                addLog(`Ë®äÊÅØÂ∑≤ÈÄÅÈÅî (${data.messageId})`, 'success');
            });

            // ÈåØË™§ËôïÁêÜ
            socket.on('error', (error) => {
                addLog(`ÈåØË™§Ôºö${error.message}`, 'error');
            });

            // Êñ∑Á∑ö
            socket.on('disconnect', () => {
                updateConnectionStatus(false);
                addLog('ÈÄ£Á∑öÂ∑≤Êñ∑Èñã', 'error');
                isEncryptionReady = false;
                updateEncryptionStatus(false);
            });
        }

        // ÂàùÂßãÂåñÂä†ÂØÜÁ≥ªÁµ±
        async function initializeCrypto() {
            try {
                if (!currentUser) {
                    addLog('Ë´ãÂÖàÈÄ£Á∑ö', 'error');
                    return;
                }

                addLog('Ê≠£Âú®ÂàùÂßãÂåñÂä†ÂØÜÁÆ°ÁêÜÂô®...', 'crypto');
                
                cryptoManager = new CryptoManager();
                await cryptoManager.initialize(currentUser.userId);
                
                isEncryptionReady = true;
                updateEncryptionStatus(true);
                
                // ÂïüÁî®Ë®äÊÅØËº∏ÂÖ•
                document.getElementById('messageInput').disabled = false;
                document.getElementById('sendBtn').disabled = false;
                
                // È°ØÁ§∫ÂØÜÈë∞‰ø°ÊÅØ (‰øÆÂæ©Áâà)
                document.getElementById('keyInfo').style.display = 'block';
                // È°ØÁ§∫ ECDH ÂÖ¨Èë∞ÊåáÁ¥ãËÄå‰∏çÊòØ currentKeyId
                const publicKeyHex = cryptoManager.myKeyPair ? 'ECDH-Â∑≤ÁîüÊàê' : 'Êú™ÁîüÊàê';
                document.getElementById('currentKeyId').textContent = `ECDH ÂØÜÈë∞: ${publicKeyHex}`;
                
                addLog('üîê ECDH Âä†ÂØÜÁ≥ªÁµ±Â∑≤Â∞±Á∑íÔºÅÂèØ‰ª•ÈñãÂßãÂÆâÂÖ®ÈÄöË®ä', 'success');
                
            } catch (error) {
                addLog(`Âä†ÂØÜÂàùÂßãÂåñÂ§±ÊïóÔºö${error.message}`, 'error');
                isEncryptionReady = false;
                updateEncryptionStatus(false);
            }
        }

        // ÁôºÈÄÅÂä†ÂØÜË®äÊÅØ - ECDH ÁâàÊú¨
        async function sendEncryptedMessage() {
            const messageInput = document.getElementById('messageInput');
            const content = messageInput.value.trim();

            if (!content) {
                addLog('Ë®äÊÅØÂÖßÂÆπ‰∏çËÉΩÁÇ∫Á©∫', 'error');
                return;
            }

            if (!selectedRecipient) {
                addLog('Ë´ãÈÅ∏ÊìáÊé•Êî∂ËÄÖ', 'error');
                return;
            }

            if (!isEncryptionReady || !cryptoManager) {
                addLog('Âä†ÂØÜÁ≥ªÁµ±Êú™Â∞±Á∑í', 'error');
                return;
            }

            try {
                addLog('Ê≠£Âú®‰ΩøÁî® ECDH Âä†ÂØÜË®äÊÅØ...', 'crypto');
                
                // ‰ΩøÁî® ECDH ÂÖ±‰∫´ÂØÜÈë∞Âä†ÂØÜË®äÊÅØ
                const encryptedMessage = await cryptoManager.encryptMessage(
                    content, 
                    selectedRecipient.userId
                );
                
                // ÁôºÈÄÅÂä†ÂØÜË®äÊÅØ
                socket.emit('sendEncryptedMessage', {
                    recipientId: selectedRecipient.userId,
                    encryptedContent: encryptedMessage,
                    messageType: 'encrypted-ecdh'
                });

                // Ê∑ªÂä†Âà∞Êú¨Âú∞ËÅäÂ§©Ë®òÈåÑ
                const message = {
                    id: Date.now().toString(),
                    senderId: currentUser.userId,
                    senderUsername: currentUser.username,
                    recipientId: selectedRecipient.userId,
                    content: content,
                    encrypted: true,
                    timestamp: new Date()
                };
                
                addMessage(message, 'sent');
                messageInput.value = '';
                
                addLog(`üîê ECDH Âä†ÂØÜË®äÊÅØÂ∑≤ÁôºÈÄÅÁµ¶ ${selectedRecipient.username}`, 'success');
                
            } catch (error) {
                addLog(`ÁôºÈÄÅ ECDH Âä†ÂØÜË®äÊÅØÂ§±ÊïóÔºö${error.message}`, 'error');
            }
        }

        // ËôïÁêÜÊé•Êî∂Âà∞ÁöÑÂä†ÂØÜË®äÊÅØ - ECDH ÁâàÊú¨
        async function handleIncomingEncryptedMessage(encryptedMessage) {
            try {
                if (!isEncryptionReady || !cryptoManager) {
                    addLog('Êî∂Âà∞Âä†ÂØÜË®äÊÅØÔºå‰ΩÜÂä†ÂØÜÁ≥ªÁµ±Êú™Â∞±Á∑í', 'error');
                    return;
                }

                addLog('Ê≠£Âú®‰ΩøÁî® ECDH Ëß£ÂØÜÊî∂Âà∞ÁöÑË®äÊÅØ...', 'crypto');
                
                // ‰ΩøÁî® ECDH ÂÖ±‰∫´ÂØÜÈë∞Ëß£ÂØÜË®äÊÅØ
                const decryptedContent = await cryptoManager.decryptMessage(
                    encryptedMessage.encryptedContent,
                    encryptedMessage.senderId
                );
                
                // ÂâµÂª∫Ë®äÊÅØÂ∞çË±°
                const message = {
                    id: encryptedMessage.id || Date.now().toString(),
                    senderId: encryptedMessage.senderId,
                    senderUsername: encryptedMessage.senderUsername,
                    content: decryptedContent,
                    encrypted: true,
                    timestamp: new Date(encryptedMessage.timestamp)
                };
                
                addMessage(message, 'received');
                addLog(`üîê ECDH Ë®äÊÅØËß£ÂØÜÊàêÂäüÔºö${encryptedMessage.senderUsername}`, 'success');
                
            } catch (error) {
                addLog(`ECDH Ëß£ÂØÜÂ§±ÊïóÔºö${error.message}`, 'error');
                
                // È°ØÁ§∫Âä†ÂØÜË®äÊÅØÔºàÁÑ°Ê≥ïËß£ÂØÜÔºâ
                const errorMessage = {
                    id: Date.now().toString(),
                    senderId: encryptedMessage.senderId,
                    senderUsername: encryptedMessage.senderUsername,
                    content: '[ECDH Âä†ÂØÜË®äÊÅØ - Ëß£ÂØÜÂ§±Êïó]',
                    encrypted: true,
                    error: true,
                    timestamp: new Date()
                };
                
                addMessage(errorMessage, 'received');
            }
        }

        // ËôïÁêÜÊôÆÈÄöË®äÊÅØÔºàÂêëÂæåÂÖºÂÆπÔºâ
        async function handleIncomingMessage(message) {
            addMessage({
                ...message,
                encrypted: false
            }, 'received');
            addLog(`Êî∂Âà∞Ë®äÊÅØÔºö${message.senderUsername}`, 'success');
        }

        // Êñ∑Á∑ö
        function disconnect() {
            if (socket) {
                socket.disconnect();
                socket = null;
                currentUser = null;
                selectedRecipient = null;
                cryptoManager = null;
                isEncryptionReady = false;
                
                updateConnectionStatus(false);
                updateEncryptionStatus(false);
                
                // Á¶ÅÁî®ÊéßÂà∂È†Ö
                document.getElementById('messageInput').disabled = true;
                document.getElementById('sendBtn').disabled = true;
                document.getElementById('initCryptoBtn').disabled = true;
                
                // Èö±ËóèÂØÜÈë∞‰ø°ÊÅØ
                document.getElementById('keyInfo').style.display = 'none';
                
                // Ê∏ÖÁ©∫Á∑ö‰∏äÁî®Êà∂
                document.getElementById('onlineUsers').innerHTML = '<div style="color: #6c757d; font-size: 12px; text-align: center;">Â∞öÁÑ°Á∑ö‰∏äÁî®Êà∂</div>';
                
                addLog('Â∑≤‰∏ªÂãïÊñ∑Á∑ö');
            }
        }

        // ËôïÁêÜ Enter Èçµ
        function handleEnterKey(event) {
            if (event.key === 'Enter') {
                sendEncryptedMessage();
            }
        }

        // Ê∑ªÂä†Ë®äÊÅØÂà∞ËÅäÂ§©Ë®òÈåÑ
        function addMessage(message, type) {
            const messagesContainer = document.getElementById('messages');
            
            // Â¶ÇÊûúÊòØÁ¨¨‰∏ÄÊ¢ùË®äÊÅØÔºåÊ∏ÖÁ©∫Ê≠°ËøéË®äÊÅØ
            if (messagesContainer.children.length === 1 && messagesContainer.children[0].style.textAlign === 'center') {
                messagesContainer.innerHTML = '';
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = message.content;
            
            // Â¶ÇÊûúÊòØÈåØË™§Ë®äÊÅØÔºåÊ∑ªÂä†ÁâπÊÆäÊ®£Âºè
            if (message.error) {
                contentDiv.style.background = '#f8d7da';
                contentDiv.style.color = '#721c24';
                contentDiv.style.border = '1px solid #f5c6cb';
            }
            
            const infoDiv = document.createElement('div');
            infoDiv.className = 'message-info';
            
            const timeSpan = document.createElement('span');
            timeSpan.textContent = `${message.senderUsername} ‚Ä¢ ${new Date(message.timestamp).toLocaleTimeString()}`;
            
            infoDiv.appendChild(timeSpan);
            
            // Ê∑ªÂä†Âä†ÂØÜÊ®ôË™å
            if (message.encrypted) {
                const encryptionBadge = document.createElement('span');
                encryptionBadge.className = 'encryption-badge';
                encryptionBadge.textContent = message.error ? 'üîí‚ùå' : 'üîí‚úì';
                infoDiv.appendChild(encryptionBadge);
            }
            
            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(infoDiv);
            messagesContainer.appendChild(messageDiv);
            
            // ÊªæÂãïÂà∞Â∫ïÈÉ®
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Êõ¥Êñ∞ÈÄ£Á∑öÁãÄÊÖã
        function updateConnectionStatus(connected) {
            const statusDiv = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            if (connected) {
                statusDiv.className = 'status connected';
                statusDiv.textContent = 'Â∑≤ÈÄ£Á∑ö';
                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'inline-block';
            } else {
                statusDiv.className = 'status disconnected';
                statusDiv.textContent = 'Êú™ÈÄ£Á∑ö';
                connectBtn.style.display = 'inline-block';
                disconnectBtn.style.display = 'none';
            }
        }

        // Êõ¥Êñ∞Âä†ÂØÜÁãÄÊÖã
        function updateEncryptionStatus(ready) {
            const statusDiv = document.getElementById('encryptionStatus');
            const iconDiv = document.getElementById('encryptionIcon');
            const textDiv = document.getElementById('encryptionText');
            
            if (ready) {
                statusDiv.className = 'status encrypted';
                statusDiv.textContent = 'üîê Âä†ÂØÜÂ∑≤Â∞±Á∑í';
                iconDiv.className = 'encryption-icon encrypted';
                textDiv.textContent = 'Á´ØÂà∞Á´ØÂä†ÂØÜ';
            } else {
                statusDiv.className = 'status disconnected';
                statusDiv.textContent = 'Âä†ÂØÜÊú™Â∞±Á∑í';
                iconDiv.className = 'encryption-icon';
                textDiv.textContent = 'Êú™Âä†ÂØÜ';
            }
        }

        // Êõ¥Êñ∞Á∑ö‰∏äÁî®Êà∂ÂàóË°®
        function updateOnlineUsers() {
            if (!socket) return;

            fetch('/api/users/online')
                .then(response => response.json())
                .then(data => {
                    const onlineUsersDiv = document.getElementById('onlineUsers');
                    onlineUsersDiv.innerHTML = '';
                    
                    if (data.users.length === 0) {
                        onlineUsersDiv.innerHTML = '<div style="color: #6c757d; font-size: 12px; text-align: center;">Â∞öÁÑ°Á∑ö‰∏äÁî®Êà∂</div>';
                        return;
                    }
                    
                    data.users.forEach(user => {
                        // ‰∏çÈ°ØÁ§∫Ëá™Â∑±
                        if (currentUser && user.userId === currentUser.userId) {
                            return;
                        }
                        
                        const userDiv = document.createElement('div');
                        userDiv.className = 'user-item';
                        userDiv.onclick = () => selectRecipient(user);
                        
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = user.username;
                        
                        const encryptionSpan = document.createElement('div');
                        encryptionSpan.className = 'user-encryption encrypted'; // ÂÅáË®≠ÊâÄÊúâÁî®Êà∂ÈÉΩÊîØÊåÅÂä†ÂØÜ
                        
                        userDiv.appendChild(nameSpan);
                        userDiv.appendChild(encryptionSpan);
                        
                        onlineUsersDiv.appendChild(userDiv);
                    });
                })
                .catch(error => {
                    addLog('Áç≤ÂèñÁ∑ö‰∏äÁî®Êà∂Â§±Êïó', 'error');
                });
        }

        // ÈÅ∏ÊìáÊé•Êî∂ËÄÖ
        function selectRecipient(user) {
            selectedRecipient = user;
            
            // Êõ¥Êñ∞UI
            document.querySelectorAll('.user-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            event.target.closest('.user-item').classList.add('selected');
            
            // Êõ¥Êñ∞ËÅäÂ§©Ê®ôÈ°å
            document.getElementById('chatTitle').textContent = `üîê Ëàá ${user.username} Âä†ÂØÜËÅäÂ§©`;
            
            addLog(`ÈÅ∏ÊìáÂä†ÂØÜËÅäÂ§©Â∞çË±°Ôºö${user.username}`, 'crypto');
        }

        // Ê∑ªÂä†Êó•Ë™å
        function addLog(message, type = 'info') {
            const logsDiv = document.getElementById('logs');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            logsDiv.appendChild(logEntry);
            logsDiv.scrollTop = logsDiv.scrollHeight;
            
            // ÈôêÂà∂Êó•Ë™åÊï∏Èáè
            while (logsDiv.children.length > 100) {
                logsDiv.removeChild(logsDiv.firstChild);
            }
        }

        // È†ÅÈù¢ËºâÂÖ•ÂÆåÊàêÂæåÁöÑÂàùÂßãÂåñ
        document.addEventListener('DOMContentLoaded', function() {
            addLog('Brotherhood Âä†ÂØÜÈÄöË®äÁ≥ªÁµ±Â∑≤Â∞±Á∑í (Á¨¨‰∫åÈöéÊÆµ)');
            addLog('ÊîØÊè¥ÂäüËÉΩÔºöÁ´ØÂà∞Á´ØÂä†ÂØÜ„ÄÅKACLS ÂØÜÈë∞ÁÆ°ÁêÜ', 'crypto');
            
            // ÂÆöÊúüÊõ¥Êñ∞Á∑ö‰∏äÁî®Êà∂ÂàóË°®
            setInterval(() => {
                if (socket && currentUser) {
                    updateOnlineUsers();
                }
            }, 5000);
        });

        // È†ÅÈù¢ÈóúÈñâÂâçÊñ∑Á∑ö
        window.addEventListener('beforeunload', function() {
            if (socket) {
                socket.disconnect();
            }
        });
    </script>
</body>
</html>