<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brotherhood åŠ å¯†é€šè¨Š - ç¬¬äºŒéšæ®µ</title>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #5671e8 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            width: 90%;
            max-width: 1100px;
            height: 800px;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background: #f8f9fa;
            border-right: 1px solid #e9ecef;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .main-chat {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 20px 20px;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .encryption-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 12px;
        }

        .encryption-icon {
            width: 16px;
            height: 16px;
            background: #ffc107;
            border-radius: 50%;
        }

        .encryption-icon.encrypted {
            background: #28a745;
        }

        .connection-section {
            margin-bottom: 20px;
        }

        .connection-section h3 {
            margin-bottom: 10px;
            color: #495057;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .input-group {
            margin-bottom: 10px;
        }

        .input-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ced4da;
            border-radius: 5px;
            font-size: 14px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
            width: 100%;
            margin-bottom: 5px;
        }

        .btn-primary {
            background: #007bff;
            color: white;
        }

        .btn-primary:hover {
            background: #0056b3;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #1e7e34;
        }

        .btn-warning {
            background: #ffc107;
            color: #212529;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .status {
            padding: 8px;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 12px;
            text-align: center;
        }

        .status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status.encrypted {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .online-users {
            flex: 1;
            overflow-y: auto;
            max-height: 150px;
        }

        .user-item {
            padding: 8px;
            margin-bottom: 5px;
            background: #e9ecef;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-item:hover {
            background: #dee2e6;
        }

        .user-item.selected {
            background: #007bff;
            color: white;
        }

        .user-encryption {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ffc107;
        }

        .user-encryption.encrypted {
            background: #28a745;
        }

        .messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            max-width: 70%;
        }

        .message.sent {
            margin-left: auto;
        }

        .message.received {
            margin-right: auto;
        }

        .message-content {
            padding: 10px 15px;
            border-radius: 20px;
            word-wrap: break-word;
        }

        .message.sent .message-content {
            background: linear-gradient(135deg, #007bff 0%, #0056b3 100%);
            color: white;
        }

        .message.received .message-content {
            background: white;
            border: 1px solid #e9ecef;
        }

        .message-info {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
            padding: 0 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .encryption-badge {
            font-size: 10px;
            background: #28a745;
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
        }

        .message-input {
            padding: 20px;
            background: white;
            border-top: 1px solid #e9ecef;
            display: flex;
            gap: 10px;
        }

        .message-input input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ced4da;
            border-radius: 25px;
            outline: none;
        }

        .message-input button {
            padding: 10px 20px;
            border-radius: 25px;
        }

        .logs {
            height: 120px;
            overflow-y: auto;
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 10px;
            font-family: monospace;
            font-size: 11px;
            margin-top: 10px;
        }

        .log-entry {
            margin-bottom: 3px;
            color: #495057;
        }

        .log-entry.error {
            color: #dc3545;
        }

        .log-entry.success {
            color: #28a745;
        }

        .log-entry.crypto {
            color: #007bff;
        }

        .crypto-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .key-info {
            background: #e7f3ff;
            border: 1px solid #b8daff;
            border-radius: 5px;
            padding: 8px;
            font-size: 11px;
            margin-bottom: 10px;
        }

        .key-id {
            font-family: monospace;
            color: #495057;
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- å´é‚Šæ¬„ -->
        <div class="sidebar">
            <!-- é€£ç·šå€åŸŸ -->
            <div class="connection-section">
                <h3>ğŸ”— é€£ç·šè¨­å®š</h3>
                <div class="input-group">
                    <input type="text" id="username" placeholder="ç”¨æˆ¶åç¨±" value="åŠ å¯†ç”¨æˆ¶1">
                </div>
                <div class="input-group">
                    <input type="text" id="userId" placeholder="ç”¨æˆ¶ID" value="enc_user1">
                </div>
                <button class="btn btn-primary" id="connectBtn" onclick="connect()">é€£ç·š</button>
                <button class="btn btn-danger" id="disconnectBtn" onclick="disconnect()" style="display:none;">æ–·ç·š</button>
                
                <div id="connectionStatus" class="status disconnected">æœªé€£ç·š</div>
            </div>

            <!-- åŠ å¯†æ§åˆ¶ -->
            <div class="connection-section">
                <h3>ğŸ” åŠ å¯†æ§åˆ¶</h3>
                <div class="crypto-controls">
                    <button class="btn btn-warning" onclick="initializeCrypto()" id="initCryptoBtn" disabled>åˆå§‹åŒ–åŠ å¯†</button>
                </div>
                <div id="encryptionStatus" class="status disconnected">åŠ å¯†æœªå°±ç·’</div>
                
                <div id="keyInfo" class="key-info" style="display:none;">
                    <div>ç•¶å‰å¯†é‘°ID:</div>
                    <div class="key-id" id="currentKeyId">-</div>
                </div>
            </div>

            <!-- ç·šä¸Šç”¨æˆ¶ -->
            <div class="connection-section">
                <h3>ğŸ‘¥ ç·šä¸Šç”¨æˆ¶</h3>
                <div class="online-users" id="onlineUsers">
                    <div style="color: #6c757d; font-size: 12px; text-align: center;">å°šç„¡ç·šä¸Šç”¨æˆ¶</div>
                </div>
            </div>

            <!-- æ—¥èªŒ -->
            <div class="connection-section">
                <h3>ğŸ“ ç³»çµ±æ—¥èªŒ</h3>
                <div class="logs" id="logs"></div>
            </div>
        </div>

        <!-- ä¸»èŠå¤©å€åŸŸ -->
        <div class="main-chat">
            <div class="chat-header">
                <span id="chatTitle">Brotherhood åŠ å¯†é€šè¨Š (ç¬¬äºŒéšæ®µ)</span>
                <div class="encryption-status">
                    <div class="encryption-icon" id="encryptionIcon"></div>
                    <span id="encryptionText">æœªåŠ å¯†</span>
                </div>
            </div>
            
            <div class="messages" id="messages">
                <div style="text-align: center; color: #6c757d; margin-top: 50px;">
                    <h3>ğŸ” æ­¡è¿ä½¿ç”¨ Brotherhood åŠ å¯†é€šè¨Šç³»çµ±</h3>
                    <p>ç¬¬äºŒéšæ®µï¼šç«¯åˆ°ç«¯åŠ å¯†åŠŸèƒ½</p>
                    <br>
                    <p>1. å…ˆé€£ç·šåˆ°æœå‹™å™¨</p>
                    <p>2. åˆå§‹åŒ–åŠ å¯†ç³»çµ±</p>
                    <p>3. é¸æ“‡ç·šä¸Šç”¨æˆ¶é–‹å§‹åŠ å¯†èŠå¤©</p>
                </div>
            </div>
            
            <div class="message-input">
                <input type="text" id="messageInput" placeholder="è¼¸å…¥è¨Šæ¯ï¼ˆå°‡è‡ªå‹•åŠ å¯†ï¼‰..." disabled onkeypress="handleEnterKey(event)">
                <button class="btn btn-success" id="sendBtn" onclick="sendEncryptedMessage()" disabled>ğŸ” ç™¼é€</button>
            </div>
        </div>
    </div>

    <script>
        let socket = null;
        let currentUser = null;
        let selectedRecipient = null;
        let cryptoManager = null;
        let isEncryptionReady = false;

        // åŠ å¯†ç®¡ç†å™¨
        class CryptoManager {
            constructor() {
                this.myKeyPair = null; // æˆ‘çš„ ECDH å¯†é‘°å°
                this.sharedSecrets = new Map(); // èˆ‡å…¶ä»–ç”¨æˆ¶çš„å…±äº«å¯†é‘°
                this.publicKeys = new Map(); // å…¶ä»–ç”¨æˆ¶çš„å…¬é‘°
                this.kaclsUrl = this.detectKaclsUrl();
            }

            // è‡ªå‹•æª¢æ¸¬ KACLS URL
            detectKaclsUrl() {
                const currentPort = window.location.port;
                return currentPort === '3001' ? 'http://localhost:3002' : '/api/kacls';
            }

            // åˆå§‹åŒ–åŠ å¯†ç³»çµ± - ç”Ÿæˆå¯†é‘°å°
            async initialize(userId) {
                try {
                    addLog('æ­£åœ¨åˆå§‹åŒ–åŠ å¯†ç³»çµ±...', 'crypto');
                    
                    // ç”Ÿæˆ ECDH å¯†é‘°å°
                    this.myKeyPair = await crypto.subtle.generateKey(
                        {
                            name: "ECDH",
                            namedCurve: "P-256"
                        },
                        false, // ä¸å¯æå–ç§é‘°
                        ["deriveKey"]
                    );

                    // å°å‡ºå…¬é‘°
                    const publicKeyBuffer = await crypto.subtle.exportKey(
                        "raw",
                        this.myKeyPair.publicKey
                    );
                    
                    const publicKeyHex = this.arrayBufferToHex(publicKeyBuffer);
                    
                    // å‘ KACLS è¨»å†Šå…¬é‘°
                    await this.registerPublicKey(userId, publicKeyHex);
                    
                    addLog(`ğŸ” å¯†é‘°å°ç”Ÿæˆå®Œæˆï¼Œå…¬é‘°å·²è¨»å†Š`, 'success');
                    return true;
                    
                } catch (error) {
                    addLog(`åŠ å¯†åˆå§‹åŒ–å¤±æ•—: ${error.message}`, 'error');
                    throw error;
                }
            }

            // å‘ KACLS è¨»å†Šå…¬é‘°
            async registerPublicKey(userId, publicKeyHex) {
                try {
                    const response = await fetch(`${this.kaclsUrl}/api/register-public-key`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            userId: userId,
                            publicKey: publicKeyHex,
                            algorithm: 'ECDH-P256'
                        })
                    });

                    if (!response.ok) {
                        throw new Error(`å…¬é‘°è¨»å†Šå¤±æ•—: ${response.status}`);
                    }

                    const result = await response.json();
                    addLog(`å…¬é‘°è¨»å†ŠæˆåŠŸ: ${result.keyId}`, 'crypto');
                    
                } catch (error) {
                    addLog(`å…¬é‘°è¨»å†Šå¤±æ•—: ${error.message}`, 'error');
                    throw error;
                }
            }

            // ç²å–å…¶ä»–ç”¨æˆ¶çš„å…¬é‘°
            async getPublicKey(userId) {
                try {
                    if (this.publicKeys.has(userId)) {
                        return this.publicKeys.get(userId);
                    }

                    const response = await fetch(`${this.kaclsUrl}/api/get-public-key/${userId}`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`ç²å–å…¬é‘°å¤±æ•—: ${response.status}`);
                    }

                    const result = await response.json();
                    
                    // å°å…¥å…¬é‘°
                    const publicKeyBuffer = this.hexToArrayBuffer(result.publicKey);
                    const publicKey = await crypto.subtle.importKey(
                        "raw",
                        publicKeyBuffer,
                        {
                            name: "ECDH",
                            namedCurve: "P-256"
                        },
                        false,
                        []
                    );

                    this.publicKeys.set(userId, publicKey);
                    addLog(`ç²å–ç”¨æˆ¶ ${userId} å…¬é‘°æˆåŠŸ`, 'crypto');
                    return publicKey;
                    
                } catch (error) {
                    addLog(`ç²å–å…¬é‘°å¤±æ•—: ${error.message}`, 'error');
                    throw error;
                }
            }

            // ç”Ÿæˆèˆ‡ç‰¹å®šç”¨æˆ¶çš„å…±äº«å¯†é‘°
            async getSharedSecret(otherUserId) {
                try {
                    if (this.sharedSecrets.has(otherUserId)) {
                        return this.sharedSecrets.get(otherUserId);
                    }

                    // ç²å–å°æ–¹å…¬é‘°
                    const otherPublicKey = await this.getPublicKey(otherUserId);

                    // åŸ·è¡Œ ECDH å¯†é‘°äº¤æ›
                    const sharedKey = await crypto.subtle.deriveKey(
                        {
                            name: "ECDH",
                            public: otherPublicKey
                        },
                        this.myKeyPair.privateKey,
                        {
                            name: "AES-GCM",
                            length: 256
                        },
                        false,
                        ["encrypt", "decrypt"]
                    );

                    this.sharedSecrets.set(otherUserId, sharedKey);
                    addLog(`èˆ‡ ${otherUserId} çš„å…±äº«å¯†é‘°ç”Ÿæˆå®Œæˆ`, 'crypto');
                    return sharedKey;
                    
                } catch (error) {
                    addLog(`å…±äº«å¯†é‘°ç”Ÿæˆå¤±æ•—: ${error.message}`, 'error');
                    throw error;
                }
            }

            // åŠ å¯†è¨Šæ¯
            async encryptMessage(plaintext, recipientId) {
                try {
                    // ç²å–èˆ‡æ”¶ä»¶äººçš„å…±äº«å¯†é‘°
                    const sharedKey = await this.getSharedSecret(recipientId);
                    
                    // æº–å‚™æ•¸æ“š
                    const encoder = new TextEncoder();
                    const data = encoder.encode(plaintext);
                    
                    // ç”Ÿæˆéš¨æ©Ÿ IV
                    const iv = crypto.getRandomValues(new Uint8Array(12)); // GCM å»ºè­° 12 bytes
                    
                    // åŠ å¯†æ•¸æ“š
                    const encryptedData = await crypto.subtle.encrypt(
                        {
                            name: "AES-GCM",
                            iv: iv
                        },
                        sharedKey,
                        data
                    );
                    
                    const result = {
                        encryptedData: this.arrayBufferToHex(encryptedData),
                        iv: this.arrayBufferToHex(iv),
                        algorithm: 'ECDH-AES-GCM',
                        timestamp: Date.now()
                    };
                    
                    addLog(`è¨Šæ¯åŠ å¯†å®Œæˆ (ECDH)`, 'crypto');
                    return result;
                    
                } catch (error) {
                    addLog(`è¨Šæ¯åŠ å¯†å¤±æ•—: ${error.message}`, 'error');
                    throw error;
                }
            }

            // è§£å¯†è¨Šæ¯
            async decryptMessage(encryptedMessage, senderId) {
                try {
                    const { encryptedData, iv, algorithm } = encryptedMessage;
                    
                    if (algorithm !== 'ECDH-AES-GCM') {
                        throw new Error(`ä¸æ”¯æŒçš„åŠ å¯†ç®—æ³•: ${algorithm}`);
                    }
                    
                    // ç²å–èˆ‡ç™¼é€è€…çš„å…±äº«å¯†é‘°
                    const sharedKey = await this.getSharedSecret(senderId);
                    
                    // è§£å¯†æ•¸æ“š
                    const decryptedData = await crypto.subtle.decrypt(
                        {
                            name: "AES-GCM",
                            iv: this.hexToArrayBuffer(iv)
                        },
                        sharedKey,
                        this.hexToArrayBuffer(encryptedData)
                    );
                    
                    const decoder = new TextDecoder();
                    const plaintext = decoder.decode(decryptedData);
                    
                    addLog(`è¨Šæ¯è§£å¯†å®Œæˆ (ECDH)`, 'crypto');
                    return plaintext;
                    
                } catch (error) {
                    addLog(`è¨Šæ¯è§£å¯†å¤±æ•—: ${error.message}`, 'error');
                    throw error;
                }
            }

            // å·¥å…·å‡½æ•¸
            hexToArrayBuffer(hex) {
                const bytes = new Uint8Array(hex.length / 2);
                for (let i = 0; i < hex.length; i += 2) {
                    bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
                }
                return bytes.buffer;
            }

            arrayBufferToHex(buffer) {
                const bytes = new Uint8Array(buffer);
                return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
            }
        }

        // é€£ç·šåˆ°æœå‹™å™¨
        function connect() {
            const username = document.getElementById('username').value.trim();
            const userId = document.getElementById('userId').value.trim();

            if (!username || !userId) {
                addLog('è«‹è¼¸å…¥ç”¨æˆ¶åç¨±å’ŒID', 'error');
                return;
            }

            // å‰µå»º Socket é€£ç·š
            socket = io('http://localhost:3001');

            // é€£ç·šäº‹ä»¶
            socket.on('connect', () => {
                addLog('é€£ç·šæˆåŠŸï¼Œæ­£åœ¨è¨»å†Š...', 'success');
                
                // è¨»å†Šç”¨æˆ¶
                socket.emit('register', { username, userId });
            });

            // è¨»å†ŠæˆåŠŸ
            socket.on('registerSuccess', (data) => {
                currentUser = data.user;
                updateConnectionStatus(true);
                addLog(`è¨»å†ŠæˆåŠŸï¼š${username}`, 'success');
                
                // å•Ÿç”¨è¨Šæ¯è¼¸å…¥å’ŒåŠ å¯†åˆå§‹åŒ–
                document.getElementById('initCryptoBtn').disabled = false;
            });

            // æ–°è¨Šæ¯
            socket.on('newMessage', async (message) => {
                await handleIncomingMessage(message);
            });

            // åŠ å¯†è¨Šæ¯
            socket.on('encryptedMessage', async (encryptedMessage) => {
                await handleIncomingEncryptedMessage(encryptedMessage);
            });

            // ç”¨æˆ¶ä¸Šç·š
            socket.on('userOnline', (data) => {
                addLog(`${data.user.username} ä¸Šç·šäº†`);
                updateOnlineUsers();
            });

            // ç”¨æˆ¶é›¢ç·š
            socket.on('userOffline', (data) => {
                addLog(`${data.username} é›¢ç·šäº†`);
                updateOnlineUsers();
            });

            // è¨Šæ¯é€é”ç¢ºèª
            socket.on('messageDelivered', (data) => {
                addLog(`è¨Šæ¯å·²é€é” (${data.messageId})`, 'success');
            });

            // éŒ¯èª¤è™•ç†
            socket.on('error', (error) => {
                addLog(`éŒ¯èª¤ï¼š${error.message}`, 'error');
            });

            // æ–·ç·š
            socket.on('disconnect', () => {
                updateConnectionStatus(false);
                addLog('é€£ç·šå·²æ–·é–‹', 'error');
                isEncryptionReady = false;
                updateEncryptionStatus(false);
            });
        }

        // åˆå§‹åŒ–åŠ å¯†ç³»çµ±
        async function initializeCrypto() {
            try {
                if (!currentUser) {
                    addLog('è«‹å…ˆé€£ç·š', 'error');
                    return;
                }

                addLog('æ­£åœ¨åˆå§‹åŒ–åŠ å¯†ç®¡ç†å™¨...', 'crypto');
                
                cryptoManager = new CryptoManager();
                await cryptoManager.initialize(currentUser.userId);
                
                isEncryptionReady = true;
                updateEncryptionStatus(true);
                
                // å•Ÿç”¨è¨Šæ¯è¼¸å…¥
                document.getElementById('messageInput').disabled = false;
                document.getElementById('sendBtn').disabled = false;
                
                // é¡¯ç¤ºå¯†é‘°ä¿¡æ¯ (ä¿®å¾©ç‰ˆ)
                document.getElementById('keyInfo').style.display = 'block';
                // é¡¯ç¤º ECDH å…¬é‘°æŒ‡ç´‹è€Œä¸æ˜¯ currentKeyId
                const publicKeyHex = cryptoManager.myKeyPair ? 'ECDH-å·²ç”Ÿæˆ' : 'æœªç”Ÿæˆ';
                document.getElementById('currentKeyId').textContent = `ECDH å¯†é‘°: ${publicKeyHex}`;
                
                addLog('ğŸ” ECDH åŠ å¯†ç³»çµ±å·²å°±ç·’ï¼å¯ä»¥é–‹å§‹å®‰å…¨é€šè¨Š', 'success');
                
            } catch (error) {
                addLog(`åŠ å¯†åˆå§‹åŒ–å¤±æ•—ï¼š${error.message}`, 'error');
                isEncryptionReady = false;
                updateEncryptionStatus(false);
            }
        }

        // ç™¼é€åŠ å¯†è¨Šæ¯ - ECDH ç‰ˆæœ¬
        async function sendEncryptedMessage() {
            const messageInput = document.getElementById('messageInput');
            const content = messageInput.value.trim();

            if (!content) {
                addLog('è¨Šæ¯å…§å®¹ä¸èƒ½ç‚ºç©º', 'error');
                return;
            }

            if (!selectedRecipient) {
                addLog('è«‹é¸æ“‡æ¥æ”¶è€…', 'error');
                return;
            }

            if (!isEncryptionReady || !cryptoManager) {
                addLog('åŠ å¯†ç³»çµ±æœªå°±ç·’', 'error');
                return;
            }

            try {
                addLog('æ­£åœ¨ä½¿ç”¨ ECDH åŠ å¯†è¨Šæ¯...', 'crypto');
                
                // ä½¿ç”¨ ECDH å…±äº«å¯†é‘°åŠ å¯†è¨Šæ¯
                const encryptedMessage = await cryptoManager.encryptMessage(
                    content, 
                    selectedRecipient.userId
                );
                
                // ç™¼é€åŠ å¯†è¨Šæ¯
                socket.emit('sendEncryptedMessage', {
                    recipientId: selectedRecipient.userId,
                    encryptedContent: encryptedMessage,
                    messageType: 'encrypted-ecdh'
                });

                // æ·»åŠ åˆ°æœ¬åœ°èŠå¤©è¨˜éŒ„
                const message = {
                    id: Date.now().toString(),
                    senderId: currentUser.userId,
                    senderUsername: currentUser.username,
                    recipientId: selectedRecipient.userId,
                    content: content,
                    encrypted: true,
                    timestamp: new Date()
                };
                
                addMessage(message, 'sent');
                messageInput.value = '';
                
                addLog(`ğŸ” ECDH åŠ å¯†è¨Šæ¯å·²ç™¼é€çµ¦ ${selectedRecipient.username}`, 'success');
                
            } catch (error) {
                addLog(`ç™¼é€ ECDH åŠ å¯†è¨Šæ¯å¤±æ•—ï¼š${error.message}`, 'error');
            }
        }

        // è™•ç†æ¥æ”¶åˆ°çš„åŠ å¯†è¨Šæ¯ - ECDH ç‰ˆæœ¬
        async function handleIncomingEncryptedMessage(encryptedMessage) {
            try {
                if (!isEncryptionReady || !cryptoManager) {
                    addLog('æ”¶åˆ°åŠ å¯†è¨Šæ¯ï¼Œä½†åŠ å¯†ç³»çµ±æœªå°±ç·’', 'error');
                    return;
                }

                addLog('æ­£åœ¨ä½¿ç”¨ ECDH è§£å¯†æ”¶åˆ°çš„è¨Šæ¯...', 'crypto');
                
                // ä½¿ç”¨ ECDH å…±äº«å¯†é‘°è§£å¯†è¨Šæ¯
                const decryptedContent = await cryptoManager.decryptMessage(
                    encryptedMessage.encryptedContent,
                    encryptedMessage.senderId
                );
                
                // å‰µå»ºè¨Šæ¯å°è±¡
                const message = {
                    id: encryptedMessage.id || Date.now().toString(),
                    senderId: encryptedMessage.senderId,
                    senderUsername: encryptedMessage.senderUsername,
                    content: decryptedContent,
                    encrypted: true,
                    timestamp: new Date(encryptedMessage.timestamp)
                };
                
                addMessage(message, 'received');
                addLog(`ğŸ” ECDH è¨Šæ¯è§£å¯†æˆåŠŸï¼š${encryptedMessage.senderUsername}`, 'success');
                
            } catch (error) {
                addLog(`ECDH è§£å¯†å¤±æ•—ï¼š${error.message}`, 'error');
                
                // é¡¯ç¤ºåŠ å¯†è¨Šæ¯ï¼ˆç„¡æ³•è§£å¯†ï¼‰
                const errorMessage = {
                    id: Date.now().toString(),
                    senderId: encryptedMessage.senderId,
                    senderUsername: encryptedMessage.senderUsername,
                    content: '[ECDH åŠ å¯†è¨Šæ¯ - è§£å¯†å¤±æ•—]',
                    encrypted: true,
                    error: true,
                    timestamp: new Date()
                };
                
                addMessage(errorMessage, 'received');
            }
        }

        // è™•ç†æ™®é€šè¨Šæ¯ï¼ˆå‘å¾Œå…¼å®¹ï¼‰
        async function handleIncomingMessage(message) {
            addMessage({
                ...message,
                encrypted: false
            }, 'received');
            addLog(`æ”¶åˆ°è¨Šæ¯ï¼š${message.senderUsername}`, 'success');
        }

        // æ–·ç·š
        function disconnect() {
            if (socket) {
                socket.disconnect();
                socket = null;
                currentUser = null;
                selectedRecipient = null;
                cryptoManager = null;
                isEncryptionReady = false;
                
                updateConnectionStatus(false);
                updateEncryptionStatus(false);
                
                // ç¦ç”¨æ§åˆ¶é …
                document.getElementById('messageInput').disabled = true;
                document.getElementById('sendBtn').disabled = true;
                document.getElementById('initCryptoBtn').disabled = true;
                
                // éš±è—å¯†é‘°ä¿¡æ¯
                document.getElementById('keyInfo').style.display = 'none';
                
                // æ¸…ç©ºç·šä¸Šç”¨æˆ¶
                document.getElementById('onlineUsers').innerHTML = '<div style="color: #6c757d; font-size: 12px; text-align: center;">å°šç„¡ç·šä¸Šç”¨æˆ¶</div>';
                
                addLog('å·²ä¸»å‹•æ–·ç·š');
            }
        }

        // è™•ç† Enter éµ
        function handleEnterKey(event) {
            if (event.key === 'Enter') {
                sendEncryptedMessage();
            }
        }

        // æ·»åŠ è¨Šæ¯åˆ°èŠå¤©è¨˜éŒ„
        function addMessage(message, type) {
            const messagesContainer = document.getElementById('messages');
            
            // å¦‚æœæ˜¯ç¬¬ä¸€æ¢è¨Šæ¯ï¼Œæ¸…ç©ºæ­¡è¿è¨Šæ¯
            if (messagesContainer.children.length === 1 && messagesContainer.children[0].style.textAlign === 'center') {
                messagesContainer.innerHTML = '';
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.textContent = message.content;
            
            // å¦‚æœæ˜¯éŒ¯èª¤è¨Šæ¯ï¼Œæ·»åŠ ç‰¹æ®Šæ¨£å¼
            if (message.error) {
                contentDiv.style.background = '#f8d7da';
                contentDiv.style.color = '#721c24';
                contentDiv.style.border = '1px solid #f5c6cb';
            }
            
            const infoDiv = document.createElement('div');
            infoDiv.className = 'message-info';
            
            const timeSpan = document.createElement('span');
            timeSpan.textContent = `${message.senderUsername} â€¢ ${new Date(message.timestamp).toLocaleTimeString()}`;
            
            infoDiv.appendChild(timeSpan);
            
            // æ·»åŠ åŠ å¯†æ¨™èªŒ
            if (message.encrypted) {
                const encryptionBadge = document.createElement('span');
                encryptionBadge.className = 'encryption-badge';
                encryptionBadge.textContent = message.error ? 'ğŸ”’âŒ' : 'ğŸ”’âœ“';
                infoDiv.appendChild(encryptionBadge);
            }
            
            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(infoDiv);
            messagesContainer.appendChild(messageDiv);
            
            // æ»¾å‹•åˆ°åº•éƒ¨
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // æ›´æ–°é€£ç·šç‹€æ…‹
        function updateConnectionStatus(connected) {
            const statusDiv = document.getElementById('connectionStatus');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            if (connected) {
                statusDiv.className = 'status connected';
                statusDiv.textContent = 'å·²é€£ç·š';
                connectBtn.style.display = 'none';
                disconnectBtn.style.display = 'inline-block';
            } else {
                statusDiv.className = 'status disconnected';
                statusDiv.textContent = 'æœªé€£ç·š';
                connectBtn.style.display = 'inline-block';
                disconnectBtn.style.display = 'none';
            }
        }

        // æ›´æ–°åŠ å¯†ç‹€æ…‹
        function updateEncryptionStatus(ready) {
            const statusDiv = document.getElementById('encryptionStatus');
            const iconDiv = document.getElementById('encryptionIcon');
            const textDiv = document.getElementById('encryptionText');
            
            if (ready) {
                statusDiv.className = 'status encrypted';
                statusDiv.textContent = 'ğŸ” åŠ å¯†å·²å°±ç·’';
                iconDiv.className = 'encryption-icon encrypted';
                textDiv.textContent = 'ç«¯åˆ°ç«¯åŠ å¯†';
            } else {
                statusDiv.className = 'status disconnected';
                statusDiv.textContent = 'åŠ å¯†æœªå°±ç·’';
                iconDiv.className = 'encryption-icon';
                textDiv.textContent = 'æœªåŠ å¯†';
            }
        }

        // æ›´æ–°ç·šä¸Šç”¨æˆ¶åˆ—è¡¨
        function updateOnlineUsers() {
            if (!socket) return;

            fetch('/api/users/online')
                .then(response => response.json())
                .then(data => {
                    const onlineUsersDiv = document.getElementById('onlineUsers');
                    onlineUsersDiv.innerHTML = '';
                    
                    if (data.users.length === 0) {
                        onlineUsersDiv.innerHTML = '<div style="color: #6c757d; font-size: 12px; text-align: center;">å°šç„¡ç·šä¸Šç”¨æˆ¶</div>';
                        return;
                    }
                    
                    data.users.forEach(user => {
                        // ä¸é¡¯ç¤ºè‡ªå·±
                        if (currentUser && user.userId === currentUser.userId) {
                            return;
                        }
                        
                        const userDiv = document.createElement('div');
                        userDiv.className = 'user-item';
                        userDiv.onclick = () => selectRecipient(user);
                        
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = user.username;
                        
                        const encryptionSpan = document.createElement('div');
                        encryptionSpan.className = 'user-encryption encrypted'; // å‡è¨­æ‰€æœ‰ç”¨æˆ¶éƒ½æ”¯æŒåŠ å¯†
                        
                        userDiv.appendChild(nameSpan);
                        userDiv.appendChild(encryptionSpan);
                        
                        onlineUsersDiv.appendChild(userDiv);
                    });
                })
                .catch(error => {
                    addLog('ç²å–ç·šä¸Šç”¨æˆ¶å¤±æ•—', 'error');
                });
        }

        // é¸æ“‡æ¥æ”¶è€…
        function selectRecipient(user) {
            selectedRecipient = user;
            
            // æ›´æ–°UI
            document.querySelectorAll('.user-item').forEach(item => {
                item.classList.remove('selected');
            });
            
            event.target.closest('.user-item').classList.add('selected');
            
            // æ›´æ–°èŠå¤©æ¨™é¡Œ
            document.getElementById('chatTitle').textContent = `ğŸ” èˆ‡ ${user.username} åŠ å¯†èŠå¤©`;
            
            addLog(`é¸æ“‡åŠ å¯†èŠå¤©å°è±¡ï¼š${user.username}`, 'crypto');
        }

        // æ·»åŠ æ—¥èªŒ
        function addLog(message, type = 'info') {
            const logsDiv = document.getElementById('logs');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            logsDiv.appendChild(logEntry);
            logsDiv.scrollTop = logsDiv.scrollHeight;
            
            // é™åˆ¶æ—¥èªŒæ•¸é‡
            while (logsDiv.children.length > 100) {
                logsDiv.removeChild(logsDiv.firstChild);
            }
        }

        // é é¢è¼‰å…¥å®Œæˆå¾Œçš„åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            addLog('Brotherhood åŠ å¯†é€šè¨Šç³»çµ±å·²å°±ç·’ (ç¬¬äºŒéšæ®µ)');
            addLog('æ”¯æ´åŠŸèƒ½ï¼šç«¯åˆ°ç«¯åŠ å¯†ã€KACLS å¯†é‘°ç®¡ç†', 'crypto');
            
            // å®šæœŸæ›´æ–°ç·šä¸Šç”¨æˆ¶åˆ—è¡¨
            setInterval(() => {
                if (socket && currentUser) {
                    updateOnlineUsers();
                }
            }, 5000);
        });

        // é é¢é—œé–‰å‰æ–·ç·š
        window.addEventListener('beforeunload', function() {
            if (socket) {
                socket.disconnect();
            }
        });
    </script>
</body>
</html>